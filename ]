//#include "functions.h"
#include<stdlib.h>
#include<stdio.h>
#include<stdint.h>
#include<string.h>
#include <stdbool.h>
#define MAX 50
int sum=0;

#define BOLD_RED "\x1b[31;1m"
#define NO_COLOR "\x1b[0;0m"
typedef struct{
	int i,j;int S_value;
} stance;
//void set_Matrix(int *mat,int sz);
//void print_Matrix(char **mat, int sz);
//void Sort_stance(stance *st,int *aux); 


int main(void){
FILE *arq;
int sz=0,al=0,col=0,value=0,aux=0,i=0,j=0;
stance st;
bool final=0;


arq = fopen("matriz", "r");
if(arq==NULL){
	printf("ERROR");
	return(1);
}
fscanf(arq, "%d %d",&sz,&col);	
printf("TAMANHO: %d %d\n", sz,sz);	
int (*mat)[sz]=malloc(sizeof(int[sz][sz]));
//set_Matrix(&mat,sz);//descobrir como passar a matriz por referencia

for(int i=0;i<sz;i++){
			for(int j=0;j<sz;j++){
				fscanf(arq,"%d",&value);
				mat[i][j]=value;
			}
		}

printf("\n");
printf("POSIÇÃO INICIAL (lin,col):\n");
scanf("%d %d",&st.i,&st.j);sum+=mat[st.i][st.j];mat[st.i][st.j]=0;st.S_value=0;//setar posição inicial,value da stance = 0
for(int i=0;i<col;i++){
		for(int j=0;j<col;j++){
			printf("%d ", mat[i][j]);
		}
	printf("\n");
}
sz-=1;
//joystick//NÃO POSSO VOLTAR PARA CIMA //PODE OCORRER VALORES IGUAIS , OPTAR PELA DIREITA U SEJA MAIOR "J"
while(!final){
	if(st.i==sz){
		while(st.j!=sz){
			sum+=mat[st.i][st.j];
			mat[st.i][st.j]=0;
			st.j+=1;
		}
		sum+=mat[st.i][st.j];
		mat[st.i][st.j]=0;
		final=1;
		break;
	}
	//adicionar função sort//preocupar com esquersa direita/diagonais inferiores
	if(st.j != 0){//posso ir para esquerda,diagonal inferior esquerda//posso fazer um pre sort antes de mandar pra função decidindo antes quais da esuqerda são maiores
		st.S_value=mat[st.i][st.j-1];
		if(st.S_value>aux){aux=st.S_value;i=st.i;j=st.j-1;}
		st.S_value=mat[st.i+1][st.j-1];
		if(st.S_value>aux){aux=st.S_value;i=st.i+1;j=st.j-1;}
	}
	if(st.j != 3){//posso ir para direita,diagonal inferior direita
		st.S_value=mat[st.i][st.j+1];
		if(st.S_value>=aux){aux=st.S_value;i=st.i;j=st.j+1;}
		st.S_value=mat[st.i+1][st.j+1];
		if(st.S_value>=aux){aux=st.S_value;i=st.i+1;j=st.j+1;}
	}
	st.S_value=mat[st.i+1][st.j];
	if(st.S_value>aux){aux=st.S_value;i=st.i+1;j=st.j;}
	st.i=i;
	st.j=j;
	sum+=aux;
	aux=0;
	mat[st.i][st.j]=0;
}
printf("\n");
printf("SOMA: %d\n",sum);
for(int i=0;i<col;i++){
		for(int j=0;j<col;j++){
			printf("%d ", mat[i][j]);
		}
	printf("\n");
}


free(mat);	

fclose(arq);
return 0;
}



/*void print_Matrix(char **mat, int sz){
	for(int i=0;i<sz;i++){
		for(int j=0;j<sz;j++){
				printf("%d", mat[i][j]);
		}
		printf("\n");
	}


	mat=(char **)malloc(sizeof(char *)*sz);
		for(int i=0;i<sz+1;i++){	
			mat[i]=(char *)malloc(sizeof(char *)*sz);
			row[strlen(row)-1]='\0';
			fgets(row,50, arq);
			printf("%s", row);
			strcpy(mat[i], row);
		}
}*/

